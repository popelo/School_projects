<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 3.0//EN//">
<html version="3"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
    <meta http-equiv="Content-language" content="cs">
    <title>IJC: DU2 </title>
</head>

<body><h1>IJC: DU2</h1>

<hr>
<p>
<b>Pozor - oprava chyby:</b>
</p><ul>
<li> v C nemáme pøetì¾ování funkcí, proto se druhý konstruktor tabulky musí jmenovat jinak:
<br> <code> t=htab_init2(size,hashfn) </code>
</li></ul>

<hr>
<hr>
<xmp>

Jazyk C                       DU2                      24.3.2016
----------------------------------------------------------------

                         Domácí úkol è.2


Termín odevzdání: 25.4.2016                       (Max. 15 bodù)

1) (max 5b)
   a) V jazyku C napi¹te program "tail.c", který  ze zadaného
   vstupního souboru vytiskne posledních  10 øádkù. Není-li
   zadán vstupní soubor, ète ze stdin. Je-li programu zadán
   parametr -n èíslo, bude se tisknout tolik posledních øádkù,
   kolik je zadáno parametrem 'èíslo'.
   Pøípadná chybová hlá¹ení tisknìte do stderr. Pøíklady:

     tail  soubor
     tail  -n 20 &lt;soubor

   [Poznámka: výsledky by mìly být +-stejné jako u POSIX pøíkazu tail]

   Je povolen implementaèní limit na délku øádku (napø. 510 znakù),
   v pøípadì prvního pøekroèení mezí hlaste chybu na stderr (øádnì otestujte)
   a pokraèujte se zkrácenými øádky (zbytek øádku pøeskoèit/ignorovat).

   b) Napi¹te stejný program jako v a) v C++11 s pou¾itím standardní
   knihovny C++. Jméno programu: "tail2.cc". Tento program
   musí zvládnout øádky libovolné délky a jejich libovolný poèet,
   jediným mo¾ným omezením je volná pamì».
   Pou¾ijte funkci
      std::getline(istream, string)
   a vhodný STL kontejner (napø. std::queue&lt;string&gt;).
   Poznámka: Pro zrychlení pou¾ijte std::ios::sync_with_stdio(false);
             proto¾e _nebudete_ pou¾ívat &lt;cstdio&gt;


2) (max 10b)
   Pøepi¹te následující C++ program do jazyka ISO C

    // wordcount-.cc
    // Pou¾ijte GCC&gt;=4.9: g++ -std=c++11
    // Pøíklad pou¾ití STL kontejneru map&lt;&gt; nebo unordered_map&lt;&gt;
    // Program poèítá èetnost slov ve vstupním textu,
    // slovo je cokoli oddìlené "bílým znakem" === isspace

    #include &lt;string&gt;
    #include &lt;iostream&gt;

    #if 1               // {0,1} - vyzkou¹ejte si obì varianty

    # include &lt;map&gt;

    int main() {
        using namespace std;
        map&lt;string,int&gt; m;  // asociativní pole - indexem je slovo
        string word;

        while (cin &gt;&gt; word) // ètení slova
            m[word]++;      // poèítání výskytù slova

        for (auto &amp;mi: m)   // pro v¹echny prvky kontejneru m
            cout &lt;&lt; mi.first &lt;&lt; "\t" &lt;&lt; mi.second &lt;&lt; "\n";
        // tisk     slovo (klíè)        poèet (data)
    }

    #else

    # include &lt;unordered_map&gt;

    int main() {
        using namespace std;
        unordered_map&lt;string,int&gt; m;  // asociativní pole
        string word;

        while (cin &gt;&gt; word) // ètení slova
            m[word]++;      // poèítání výskytù slova

        for (auto &amp;mi: m)   // pro v¹echny prvky kontejneru m
            cout &lt;&lt; mi.first &lt;&lt; "\t" &lt;&lt; mi.second &lt;&lt; "\n";
        // tisk     slovo (klíè)        poèet (data)
    }

    #endif

   Výstupy programù musí být pro stejný vstup stejné (kromì poøadí a pøíli¹ dlouhých slov).
   Výsledný program se musí jmenovat "wordcount.c".

   Ve¹keré operace s tabulkou budou v samostatné knihovnì (vytvoøte statickou
   i dynamickou/sdílenou verzi).  V knihovnì musí být ka¾dá funkce ve
   zvlá¹tním modulu - to umo¾ní pøípadnou výmìnu hash_function() ve va¹em
   staticky sestaveném programu (vyzkou¹ejte si to: definujte svoji
   hash_function v programu).

   Knihovna s tabulkou se musí jmenovat
   "libhtable.a" (na Windows je mo¾né i "htable.lib") pro statickou variantu,
   "libhtable.so" (na Windows je mo¾né i "htable.dll") pro sdílenou variantu
   a rozhraní "htable.h".

   Podmínky:
    - Implementace musí být dynamická (malloc/free) a musíte zvládnout
      správu pamìti v C (pou¾ijte valgrind, nebo jiný podobný nástroj).

    - Asociativní pole implementujte nejdøíve prototypovì jednoduchým seznamem
      a potom tabulkou (hash table). Odevzdává se øe¹ení s tabulkou.

    - Vhodná rozptylovací funkce pro øetìzce je podle literatury
      (http://www.cse.yorku.ca/~oz/hash.html varianta sdbm):

        unsigned int hash_function(const char *str, unsigned htab_size) {
          unsigned int h=0;
          const unsigned char *p;
          for(p=(const unsigned char*)str; *p!='\0'; p++)
              h = 65599*h + *p;
          return h % htab_size;
        }

      její výsledek urèuje index do tabulky.
      Zkuste pou¾ít i jiné podobné funkce.

    - Tabulka je struktura obsahující pole seznamù, jeho velikost,
      ukazatel na rozptylovací funkci a poèet polo¾ek tabulky
      v následujícím poøadí:

         +--------------+
         | htab_size    | // velikost pole
         +--------------+
         | hash_fun_ptr | // implicitnì obsahuje &amp;hash_function
         +--------------+
         | n            | // aktuální poèet záznamù
         +--------------+
         +---+
         |ptr|--&gt;[key,data,next]--&gt;[key,data,next]--&gt;[key,data,next]--|
         +---+
         |ptr|--&gt;[key,data,next]--&gt;[key,data,next]--|
         +---+
         |ptr|--|
         +---+

      Polo¾ka htab_size je velikost následujícího pole ukazatelù (pou¾ijte
      C99: "flexible array member"). Pamì» pro strukturu se dynamicky alokuje
      tak velká, aby se do ní ve¹ly v¹echny polo¾ky pole.
      V programu zvolte vhodnou velikost pole a v komentáøi zdùvodnìte va¹e
      rozhodnutí.
      (V obrázku platí velikost htab_size==3 a poèet polo¾ek n==5.)

    - Napi¹te funkce

        t=htab_init(size)         pro vytvoøení a inicializaci tabulky
        t=htab_init2(size,hashfn)  pro vytvoøení a inicializaci tabulky s jinou
                                  ne¾ implicitní rozptylovací funkcí

        ptr=htab_lookup_add(t,key)    vyhledávání - viz dále

        htab_foreach(t,func)      volání funkce func pro ka¾dý prvek

        htab_remove(t,key)        vyhledání a zru¹ení zadané polo¾ky

        htab_clear(t)             zru¹ení v¹ech polo¾ek v tabulce

        htab_free(t)              zru¹ení celé tabulky (volá clear)

      kde t,t1,t2 je ukazatel na tabulku (typu htab_t *),
          b       je typu bool,
          ptr     je ukazatel na záznam (polo¾ku tabulky),
          func    je funkce s parametry (key,value)

    - Vhodnì zvolte typy parametrù funkcí.

    - Záznam [key,data,next] je typu
          struct htab_listitem
      a obsahuje polo¾ky:
          key .... ukazatel na dynamicky alokovaný øetìzec,
          data ... poèet výskytù a
          next ... ukazatel na dal¹í záznam

    - Funkce  htab_foreach(t,function)  volá zadanou funkci pro ka¾dý prvek
      tabulky, obsah tabulky nemìní. (Vhodné napø. pro tisk obsahu.)

    - Funkce
        struct htab_listitem * htab_lookup_add(htab_t *t, const char *key);
      v tabulce  t  vyhledá záznam odpovídající øetìzci  key  a
        - pokud jej nalezne, vrátí ukazatel na záznam
        - pokud nenalezne, automaticky pøidá záznam a vrátí ukazatel
      Poznámka: Dobøe promyslete chování této funkce k parametru key.

    - Pokud htab_init nebo htab_lookup_add nemohou alokovat pamì», vrací NULL


    - Napi¹te funkci

        int get_word(char *s, int max, FILE *f);

      která ète jedno slovo ze souboru f do zadaného pole znakù
      a vrátí délku slova (z del¹ích slov naète prvních max-1 znakù,
      a zbytek pøeskoèí). Funkce vrací EOF, pokud je konec souboru.
      Umístìte ji do zvlá¹tního modulu "io.c" (nepatøí do knihovny).
      Poznámka: Slovo je souvislá posloupnost znakù oddìlená isspace znaky.

    Omezení: øe¹ení v C mù¾e tisknout jinak seøazený výstup
      a je povoleno pou¾ít implementaèní limit na maximální
      délku slova (zvolte 127 znakù), del¹í slova se ZKRÁTÍ a program
      pøi prvním del¹ím slovu vytiskne varování na stderr (max 1 varování).

    Poznámka: Vhodný soubor pro testování je napøíklad seznam slov
              v souboru /usr/share/dict/words
              nebo texty z http://www.gutenberg.org/
              pøípadnì výsledek pøíkazu:  seq 1000000 2000000|shuf


    [[ Pokud se nìkdo nudí, napí¹e si variantu tabulky s automatickým
    zvìt¹ováním/zmen¹ováním velikosti tak, aby prùmìrná délka seznamù
    nepøesahovala rozumnou mez (experimentálnì zjistit).

        htab_resize(&amp;t1,newsize)  zmìna velikosti tabulky (zachová obsah,
                                  ale zmìní t1)

    Toto øe¹ení se neodevzdává ani nehodnotí, ale mù¾e se hodit po zkou¹ce na
    pøidání nìkolika bodù. ]]

(10b)

Pou¾ijte implicitní lokalizaci (= nevolat setlocale()).

Napi¹te soubor Makefile tak, aby pøíkaz make vytvoøil programy
"tail", "tail2", "wordcount", "wordcount-dynamic" a knihovny "libhtable.a",
"libhtable.so" (nebo "htable.DLL").
Program "wordcount" musí být staticky sestaven s knihovnou "libhtable.a".
Program "wordcount-dynamic" musí být sestaven s knihovnou "libhtable.so".
Tento program otestujte se stejnými vstupy jako u staticky sestavené verze.

Porovnejte efektivitu obou (C i C++) implementací (viz napø. pøíkaz time)
a zamyslete se nad výsledky (pozor na vliv vyrovnávacích pamì»í atd.)
Také si zkuste pøeklad s optimalizací i bez ní (-O2, -O0) a porovnejte
efektivitu pro vhodný vstup.

Poznámky:
 - 1b) pokud mo¾no maximálnì vyu¾ívejte standardní knihovny C++
 - 2) pro testy wordcount-dynamic na linuxu budete potøebovat nastavit
      LD_LIBRARY_PATH="."   (viz "man ld.so" a odpovídající pøedná¹ka)
 - Ètìte pokyny pro vypracování domácích úkolù (viz dále)

----------------------------------------------------------------

Obecné pokyny pro vypracování domácích úkolù

*  Pro úkoly v jazyce C pou¾ívejte ISO C99 (soubory *.c)
   Pro úkoly v jazyce C++ pou¾ívejte ISO C++11 (soubory *.cc)
   Pou¾ití nepøenositelných konstrukcí není dovoleno.

*  Úkoly zkontrolujte pøekladaèem napøíklad takto:
      gcc -std=c99 -pedantic -Wall -Wextra priklad1.c
      g++ -std=c++11 -pedantic -Wall priklad.cc
   Místo gcc mù¾ete pou¾ít i jiný pøekladaè - podle va¹eho prostøedí.
   V  souvislosti s tím napi¹te do poznámky na zaèátku
   souboru jméno a verzi pøekladaèe, kterým byl program pøelo¾en
   (implicitní je GCC `g++ --version` na poèítaèi merlin).

*  Programy  pi¹te, pokud je to mo¾né, do jednoho zdrojového
   souboru. Dodr¾ujte pøedepsaná jména souborù.

*  Na zaèátek ka¾dého souboru napi¹te poznámku, která bude
   obsahovat jméno, fakultu, oznaèení pøíkladu a datum.

* Úkoly je nutné zabalit programem zip takto:
       zip xnovak99.zip *.c *.cc *.h Makefile

  Jméno xnovak99 nahradíte vlastním. Formát souboru bude ZIP.
  Archiv neobsahuje adresáøe.  Ka¾dý si zkontroluje obsah ZIP archivu jeho
  rozbalením v prázdném adresáøi a napsáním "make".

* Posílejte pouze nezbytnì nutné soubory -- ne *.EXE !

* Øe¹ení se odevzdává elektronicky v IS FIT

* Úkoly neodevzdané v termínu (podle WIS) budou za 0 bodù.

* Opsané úkoly budou hodnoceny 0 bodù pro v¹echny zùèastnìné
  a to bez výjimky (+ bonus v podobì náv¹tìvy u disciplinární komise).


</xmp>
<hr>
<address>
Poslední modifikace: <!-- begin flastmod -->
11. April 2016<!-- end -->
<br>
Pokud naleznete na této stránce chybu, oznamte to dopisem na adresu
peringer AT fit.vutbr.cz
</address>



</body></html>